---
title: 多线程
categories: 技术分享    
---

![](/img/con_pro.png)  

![](/img/thread.png)  

# 问题

* 在并发编程领域，有两大核心问题：一个是互斥，即同一时刻只允许一个线程访问共享资源；另一个是同步，即线程之间如何通信、协作。   

* 缓存导致的可见行问题
        一个线程对共享变量的修改，另一个线程能够立刻看到——可见性   
* 线程切换带来的原子性问题   
* 变异优化带来的有序性问题

* Java内存模型规范了jvm如何提供按需禁用缓存和编译优化的方法：volatile、synchronized、final 关键字及六项happens-before【前一个操作的结果对后续的操作是可见的】原则。   

* volatile:原始意义为禁用cpu缓存   

* final 修饰变量时，初衷是告诉编译器：这个变量生而不变，可以可劲儿优化   

* <font color=#FF0000 > 不能用可变对象做锁 </font>

## 1 程序的顺序性规则：
        这条规则是指在一个线程中，按照程序顺序，前面的操作 Happens-Before 于后续的任意操作   

```
// 以下代码来源于【参考1】
class VolatileExample {
  int x = 0;
  volatile boolean v = false;
  public void writer() {
    x = 42;
    v = true;
  }
  public void reader() {
    if (v == true) {
      // 这里x会是多少呢？
    }
  }
}
```

## 2 volatile 变量规则
    这条规则是指对一个 volatile 变量的写操作， Happens-Before 于后续对这个 volatile 变量的读操作。
## 3 传递性
    这条规则是指如果 A Happens-Before B，且 B Happens-Before C，那么 A Happens-Before C。
## 4 管程中的锁规则【synchronzied】
    这条规则是指对一个锁的解锁 Happens-Before 于后续对这个锁的加锁。
## 5 线程start规则
    它是指主线程 A 启动子线程 B 后，子线程 B 能够看到主线程在启动子线程 B 前的操作。
## 6 线程join规则
    它是指主线程 A 等待子线程 B 完成（主线程 A 通过调用子线程 B 的 join() 方法实现），当子线程 B 完成后（主线程 A 中 join() 方法返回），主线程能够看到子线程的操作。当然所谓的“看到”，指的是对共享变量的操作。


## 死锁条件
+ 互斥，共享资源 X 和 Y 只能被一个线程占用；
+ 占有且等待，线程 T1 已经取得共享资源 X，在等待共享资源 Y 的时候，不释放共享资源 X；
+ 不可抢占，其他线程不能强行抢占线程 T1 占有的资源；
+ 循环等待，线程 T1 等待线程 T2 占有的资源，线程 T2 等待线程 T1 占有的资源，就是循环等待。

## 用“等待-通知”机制优化循环等待
    Java 语言内置的 synchronized 配合 wait()、notify()、notifyAll() 这三个方法就能轻松实现。
# 注意的问题
## 安全性问题
## 活跃性问题
## 性能问题

# 管程，对应的英文是 Monitor


<font color=#FF0000 > 管程，指的是管理共享变量以及对共享变量的操作过程，让他们支持并发。翻译为 Java 领域的语言，就是管理类的成员变量和成员方法，让这个类是线程安全的 </font>

管程解决互斥问题的思路很简单，就是将共享变量及其对共享变量的操作统一封装起来。

# 线程数量
对于 CPU 密集型计算，多线程本质上是提升多核 CPU 的利用率，所以对于一个 4 核的 CPU，每个核一个线程，理论上创建 4 个线程就可以了，再多创建线程也只是增加线程切换的成本。所以，对于 CPU 密集型的计算场景，理论上“线程的数量 =CPU 核数”就是最合适的。不过在工程上，线程的数量一般会设置为“CPU 核数 +1”，这样的话，当线程因为偶尔的内存页失效或其他原因导致阻塞时，这个额外的线程可以顶上，从而保证 CPU 的利用率。   

对于 I/O 密集型的计算场景，比如前面我们的例子中，如果 CPU 计算和 I/O 操作的耗时是 1:1，那么 2 个线程是最合适的。如果 CPU 计算和 I/O 操作的耗时是 1:2，那多少个线程合适呢？是 3 个线程；最佳线程数 =CPU 核数 * [ 1 +（I/O 耗时 / CPU 耗时）]    
<font color=#FF0000 > 伪标准（经验值）：2 * CPU 的核数 + 1 </font>


# Lock，Condition
Java SDK 并发包通过 Lock 和 Condition 两个接口来实现管程，其中 Lock 用于解决互斥问题，Condition 用于解决同步问题。

* 永远只在更新对象的成员变量时加锁
* 永远只在访问可变的成员变量时加锁
* 永远不在调用其他对象的方法时加锁

# Semaphore
# 读写锁
* 允许多个线程同时读共享变量
* 只允许一个线程写共享变量
* 如果一线程在写共享变量，此时禁止读进程读共享变量
# StampedLock

# Thread,Runnable
    继承Thread类，并重写run方法

    实现Runnable接口


# 线程间的通信
锁与同步


# 信号量
    volatile关键字能够保证内存的可⻅性，如果⽤volatile关键字声明了⼀个变 量，在⼀个线程⾥⾯改变了这个变量的值，那其它线程是⽴⻢可⻅更改后的 值的。


    sleep⽅法是不会释放当前的锁的，⽽wait⽅法会
     
    


