---
title: XXXX
categories: 技术分享    
---
# Java

强
软
弱——
虚：与队列结合使用——实际无使用场景；管理直接内存；

## Arraylist 与 LinkedList、Vector 区别
    Arraylist 与 LinkedList 两个都是不保证线程安全；Vector是线程安全的；
    Arraylist 底层数据结构是数组；LinkedList是双向链表；

## HashMap原理
HashMap主要由数组和链表组成，他不是线程安全的。核心的点就是put插入数据的过程，get查询数据以及扩容的方式。JDK1.7和1.8的主要区别在于头插和尾插方式的修改，头插容易导致HashMap链表死循环，并且1.8之后加入红黑树对性能有提升。
* put插入数据流程
往map插入元素的时候首先通过对key hash然后与数组长度-1进行与运算((n-1)&hash)，都是2的次幂所以等同于取模，但是位运算的效率更高。找到数组中的位置之后，如果数组中没有元素直接存入，反之则判断key是否相同，key相同就覆盖，否则就会插入到链表的尾部，如果链表的长度超过8，则会转换成红黑树，最后判断数组长度是否超过默认的长度*负载因子也就是12，超过则进行扩容。
* get查询数据
查询数据相对来说就比较简单了，首先计算出hash值，然后去数组查询，是红黑树就去红黑树查，链表就遍历链表查询就可以了。
* resize扩容过程
扩容的过程就是对key重新计算hash，然后把数据拷贝到新的数组。

hash冲突.链地址法
　　 这种方法的基本思想是将所有哈希地址为i的元素构成一个称为同义词链的单链表，并将单链表的头指针存在哈希表的第i个单元中，因而查找、插入和删除主要在同义词链中进行。链地址法适用于经常进行插入和删除的情况。

## ConcurrentHashMap
采⽤CAS和synchronized来保证并发安全;
数据结构跟HashMap1.8的结构类似，数组+链表/红⿊⼆叉树;synchronized只锁定当前链表或红⿊⼆叉树的⾸节点，这样只要hash不冲突，就不会产⽣并发，效率⼜提升N倍。

## 并发与并⾏
并发：同一时间段，有多个任务在执行；
并行：单位时间内，多个任务同时执行；

并发编程的⽬的就是为了能提⾼程序的执⾏效率，但是并发编程并不总是能提⾼程序运⾏速度的，⽽且并发编程可能会遇到很多问题，⽐如：内存泄漏、上下⽂切换、死锁还有受限于硬件和软件的资源闲置问题。
## 死锁
互斥；请求并保持；不可剥夺；循环等待；

## 为什么我们调⽤ start() ⽅法时会执⾏ run() ⽅法
调用start方法可启动线程并是使线程进入就绪状态；为调用run只是一个普通方法调用；

## 进程和线程的区别
进程：资源分配的基本单位；
线程：程序执行的基本单位；

进程是程序的一次执行，是系统进行资源分配和调度的独立单位，他的作用是是程序能够并发执行提高资源利用率和吞吐率。
由于进程是资源分配和调度的基本单位，因为进程的创建、销毁、切换产生大量的时间和空间的开销，进程的数量不能太多，而线程是比进程更小的能独立运行的基本单位，他是进程的一个实体，可以减少程序并发执行时的时间和空间开销，使得操作系统具有更好的并发性。线程基本不拥有系统资源，只有一些运行时必不可少的资源，比如程序计数器、寄存器和栈，进程则占有堆、栈。

## synchronized原理
synchronized关键字解决的是多个线程之间访问资源的同步性，synchronized关键字可以保证被它修饰的⽅法或者代码块在任意时刻只能有⼀个线程执⾏。

synchronized是java提供的原子性内置锁，这种内置的并且使用者看不到的锁也被称为监视器锁，使用synchronized之后，会在编译之后在同步的代码块前后加上monitorenter和monitorexit字节码指令，他依赖操作系统底层互斥锁实现。他的作用主要就是实现原子性操作和解决共享变量的内存可见性问题。
执行monitorenter指令时会尝试获取对象锁，如果对象没有被锁定或者已经获得了锁，锁的计数器+1。此时其他竞争锁的线程则会进入等待队列中。
执行monitorexit指令时则会把计数器-1，当计数器值为0时，则锁释放，处于等待队列中的线程再继续竞争锁。
synchronized是排它锁，当一个线程获得锁之后，其他线程必须等待该线程释放锁后才能获得锁，而且由于Java中的线程和操作系统原生线程是一一对应的，线程被阻塞或者唤醒时时会从用户态切换到内核态，这种转换非常消耗性能。

从内存语义来说，加锁的过程会清除工作内存中的共享变量，再从主内存读取，而释放锁的过程则是将工作内存中的共享变量写回主内存。
 

## ReentrantLock 
相比于synchronized，ReentrantLock需要显式的获取锁和释放锁，
和synchronized有什么区别   
等待可中断，当持有锁的线程长时间不释放锁的时候，等待中的线程可以选择放弃等待，转而处理其他的任务。
公平锁：synchronized和ReentrantLock默认都是非公平锁，但是ReentrantLock可以通过构造函数传参改变。只不过使用公平锁的话会导致性能急剧下降。   
绑定多个条件：ReentrantLock可以同时绑定多个Condition条件对象。


## volatile 
volatile关键字的主要作⽤就是保证变量的可⻅性然后还有⼀个作⽤是防⽌指令重排序

## ThreadLocal
个 ThreadLocal 变量，那么访问这个变量的每个线程都会有这个变量的本地副本，这也是 ThreadLocal 变量名的由来。他们可以使⽤ get（） 和 set（） ⽅法来获取默认值或将其值更改为当前线程所存的副本的值，从⽽避免了线程安全问题。

## 线程池
池化技术的思想主要是为了减少每次获取资源的消耗，提⾼对资源的利⽤率。
降低资源消耗。提⾼响应速度。提⾼线程的可管理性。

Runnable 接⼝不会返回结果或抛出检查异常，但是 Callable 接⼝可以；
execute() ⽅法⽤于提交不需要返回值的任务，所以⽆法判断任务是否被线程池执⾏成功与否；

submit() ⽅法⽤于提交需要返回值的任务。线程池会返回⼀个 Future 类型的对象，通过这个 Future 对象可以判断任务是否执⾏成功，并且可以通过 Future 的 get() ⽅法来获取返回值， get() ⽅法会阻塞当前线程直到任务完成，⽽使⽤ get（long timeout，TimeUnit unit） ⽅法则会阻塞当前线程⼀段时间后⽴即返回，这时候有可能任务没有执⾏
完。

1 先判断线程池中的核心线程们是否空闲，如果空闲，就把这个新的任务指派给某一个空闲线程去执行。
2 如果没有空闲，并且当前线程池中的核心线程数还小于 corePoolSize，那就再创建一个核心线程。
3 如果线程池的线程数已经达到核心线程数，并且这些线程都繁忙，就把这个新来的任务放到等待队列中去。
4 如果等待队列又满了，那么查看一下当前线程数是否到达maximumPoolSize，如果还未到达，就继续创建线程。如果已经到达了，就交给

RejectedExecutionHandler来决定怎么处理这个任务。
AbortPolicy 来拒绝新任务的处理。直接抛出异常，这是默认策略；
CallerRunsPolicy：用调用者所在的线程来执行任务；
DiscardPolicy ： 不处理新任务，直接丢弃掉。
DiscardOldestPolicy ： 此策略将丢弃最早的未处理的任务请求。

## AbstractQueuedSynchronizer 
AQS（Abstract Queued Synchronizer）是一个抽象的队列同步器，通过维护一个共享资源状态（Volatile Int State）和一个先进先出（FIFO）的线程等待队列来实现一个多线程访问共享资源的同步框架。

AQS为每个共享资源都设置一个共享资源锁，线程在需要访问共享资源时首先需要获取共享资源锁，如果获取到了共享资源锁，便可以在当前线程中使用该共享资源，如果获取不到，则将该线程放入线程等待队列，等待下一次资源调度

AQS定义了两种资源共享方式：独占式（Exclusive）和共享式（Share）。
◎ 独占式：只有一个线程能执行，具体的Java实现有ReentrantLock。
◎ 共享式：多个线程可同时执行，具体的Java实现有Semaphore和CountDownLatch。

## CAS 
CAS操作的就是乐观锁，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。

CAS叫做CompareAndSwap，比较并交换，主要是通过处理器的指令来保证操作的原子性，它包含三个操作数：
变量内存地址，V表示
旧的预期值，A表示
准备设置的新值，B表示
当执行CAS指令时，只有当V等于A时，才会用B去更新V的值，否则就不会执行更新操作

缺点：ABA问题；循环时间长开销大;只能保证一个共享变量的原子操作
# JVM
## 对象创建的过程
类加载检查；分配内存；初始化零值；设置对象头；执行init方法；
堆内存非配策略：对象优先在新生区；大对象进老年代；长期存活的锦老年代；

#### 判断无用的常量
假如在常量池中存在字符串 "abc"，如果当前没有任何String对象引⽤该字符串常量的话，就说明常量
"abc" 就是废弃常量，如果这时发⽣内存回收的话⽽且有必要的话，"abc" 就会被系统清理出常量池。


##### 判断无用的类
该类的所有实例被回收；
该类的classloader被回收；
该类对应的 Class对象没有任何地方被引用，无法在任何地方通过反射访问；


# 网络
## TCP 三次握手


## 锁的优化机制
无锁->偏向锁->轻量级锁->重量级锁   

自旋锁：由于大部分时候，锁被占用的时间很短，共享变量的锁定时间也很短，所有没有必要挂起线程，用户态和内核态的来回上下文切换严重影响性能。自旋的概念就是让线程执行一个忙循环，可以理解为就是啥也不干，防止从用户态转入内核态，自旋锁可以通过设置-XX:+UseSpining来开启，自旋的默认次数是10次，可以使用-XX:PreBlockSpin设置。   

自适应锁 


# Spring 
## spring 用到的模式：
* 单例模式：Spring 中的 Bean 默认情况下都是单例的
* 工厂模式：工厂模式主要是通过 BeanFactory 和 ApplicationContext 来生产 Bean 对象。
* 代理模式：最常见的 AOP 的实现方式就是通过代理来实现，Spring主要是使用 JDK 动态代理和 CGLIB 代理。
* 模板方法模式：主要是一些对数据库操作的类用到，比如 JdbcTemplate、JpaTemplate，因为查询数据库的建立连接、执行查询、关闭连接几个过程，非常适用于模板方法。

## IOC AOP
ioc 是⼀种设计思想：就是将原本在程序中⼿动创建对象的控制
权，交由Spring框架来管理；将对象之间的相互依赖关系交给 IoC 容器来管理，并由 IoC 容器完成对象的注⼊;提供了BeanFactory和applicationContext来管理

AOP面向切面编程；他是一个编程范式，目的是提高代码的模块性；基于动态代理的方式实现；如果实现了接口的话就会使用JDK动态代理，否则使用CGLIB代理；Spring中 AOP 的应用主要体现在 事务、日志、异常处理等方面，通过在代码的前后做一些增强处理，可以实现对业务逻辑的隔离，提高代码的模块化能力，同时也是解耦。Spring主要提供了 Aspect 切面、JoinPoint 连接点、PointCut 切入点、Advice 增强等实现方式。

Spring AOP 基于动态代理实现，属于运行时增强。
AspectJ 则属于编译时增强，主要有3种方式：
就是 Spring AOP 只能在运行时织入，不需要单独编译，性能相比 AspectJ 编译织入的方式慢，而 AspectJ 只支持编译前后和类加载时织入，性能更好，功能更加强大


BeanFactory 是 Bean 的工厂， ApplicationContext 的父类，IOC 容器的核心，负责生产和管理 Bean 对象。


FactoryBean 是 Bean，可以通过实现 FactoryBean 接口定制实例化 Bean 的逻辑，通过代理一个Bean对象，对方法前后做一些操作。
## Spring 中的 bean 的作⽤域有
* singleton : 唯⼀ bean 实例，Spring 中的 bean 默认都是单例的。
* prototype : 每次请求都会创建⼀个新的 bean 实例
* request : 每⼀次HTTP请求都会产⽣⼀个新的bean，该bean仅在当前HTTP request内有效
* session : 每⼀次HTTP请求都会产⽣⼀个新的 bean，该bean仅在当前 HTTP session 内有效。
* global-session： 全局session作⽤域，仅仅在基于portlet的web应⽤中才有意义，Spring5已
经没有了。

单例 bean 存在线程问题，主要是因为当多个线程操作同⼀个对象的时候，对这个对象的⾮静态成员变量的写操作会存在线程安全问题。

    在Bean对象中尽量避免定义可变的成员变量
    在类中定义⼀个ThreadLocal成员变量，将需要的可变成员变量保存在 ThreadLocal 中（推荐的⼀种⽅式）。

## @Component 和 @Bean 的区别是什么
 作⽤对象不同: @Component 注解作⽤于类，⽽ @Bean 注解作⽤于⽅法

## 将⼀个类声明为Spring的 bean 的注解有哪些
@Component;@Repository;@Service;@Controller

## SpringBean生命周期

* 实例化，创建一个Bean对象
    
* 填充属性，为属性赋值——按照spring上下文对实例化的bean进行配置——ioc注入
* 初始化
    如果实现了 xxxAware 接口，通过不同的aware接口拿到apring容器的资源
    如果实现了beanPostProcessor接口，则会调用该接口的postProcessBeforInitiazation 和postProcessAfterInitiazation方法
    如果配置了init-mathod方法，则会执行改方法 
* 销毁
    容器关闭后，如果bean实现了DisposeableBean接口，则会调用该接口的destroy方法
    如果配置了destroy-method方法，则会执行该方法

## Spring是怎么解决循环依赖的
三级缓存：
第一级缓存：用来保存实例化、初始化都完成的对象
第二级缓存：用来保存实例化完成，但是未初始化完成的对象
第三级缓存：用来保存一个对象工厂，提供一个匿名内部类，用于创建二级缓存中的对象

## Spring事务的隔离级别
isolation_default:——mysql repeatable-read
readUncommit
readcommit
repeat-read
serializable 串行

read uncommit 读未提交，可能会读到其他事务未提交的数据，也叫做脏读。
read commit 读已提交，两次读取结果不一致，叫做不可重复读。不可重复读解决了脏读的问题，他只会读取已经提交的事务。
repeatable read 可重复复读，这是mysql的默认级别，就是每次读取结果都一样，但是有可能产生幻读。
serializable 串行，一般是不会使用的，他会给每一行读取的数据加锁，会导致大量超时和锁竞争的问题。

## Spring事务传播机制
Propagation_required:如果当前没有事务，就创建一个新的，存在就加入该事务；——默认选择
requires_new ：不管存不存在都创建新事务
nested:如果当前存在事务，则嵌入事务内部执行，如果没有就创建新的事务
not_supported：以非事务方式执行操作，存在就把当前事务挂起
never：以非事务方式执行操作，存在就跑出异常
mandatory:支持当前事务，如果当前事务存在，就加入该事务，如果不存在则抛出异常；
supports：如果当前事务存在，就加入该事务，不存在就以非事务执行

## 反射
    将类的各个部分封装成其他属性；Field Constructor Method   

    获取public   
        getFields():Field []    
        getField(String a):Field   
        
    获取所有：要忽略访问修饰符的安全规则——setAccessible(true);暴力反射   
        getDeclaredFields():Field []    
        getDeclaredField(String a):Field   

    Field 获取属性、设置值   
    Constructor 创建对象   
    Method 执行方法 invoke()   

## 说说Spring Boot 启动流程

* 准备环境，根据不同的环境创建不同的Environment
* 准备、加载上下文，为不同的环境选择不同的Spring Context，然后加载资源，配置Bean   
* 初始化，这个阶段刷新Spring Context，启动应用
* 最后结束流程

# Mysql
myisam:支持全文检索、压缩、空间函数……；不支持事务及行级锁；一般用于读多写少的场景；不支持外键，索引与数据分开存储。
innodb:基于聚簇索引建立的，支持事物，外键；
    并通过MVCC来支持高并发、索引和数据存储在一起；


## 索引
按照数据结构：B+树和hash索引；
B+ 树时左小右大的顺序存储结构，节点只包含id索引列，而叶子结点包含索引列和数据——聚簇索引；一张表只能有一个主键作为聚簇索引；假设没有定义主键，InnoDB会选择一个唯一的非空索引代替，如果没有的话则会隐式定义一个主键作为聚簇索引。

索引覆盖和回表：覆盖索引指的是在一次查询中，如果一个索引包含或者说覆盖所有需要查询的字段的值，我们就称之为覆盖索引，而不再需要回表查询。而要确定一个查询是否是覆盖索引，我们只需要explain sql语句看Extra的结果是否是“Using index”即可。

## mysql锁分为共享锁和排他锁，也叫做读锁和写锁
读锁是共享的，可以通过lock in share mode实现，这时候只能读不能写。
写锁是排他的，它会阻塞其他的写锁和读锁。从颗粒度来区分，可以分为表锁和行锁两种。
表锁会锁定整张表并且阻塞其他用户对该表的所有读写操作，比如alter修改表结构的时候会锁表。

行锁又可以分为乐观锁和悲观锁，悲观锁可以通过for update实现，乐观锁则通过版本号实现。

## 事务
* 原子性指的是一个事务中的操作要么全部成功，要么全部失败。
* 一致性指的是数据库总是从一个一致性的状态转换到另外一个一致性的状态。比如A转账给B100块钱，假设中间sql执行过程中系统崩溃A也不会损失100块，因为事务没有提交，修改也就不会保存到数据库。
* 隔离性指的是一个事务的修改在最终提交前，对其他事务是不可见的。
* 持久性指的是一旦事务提交，所做的修改就会永久保存到数据库中。

read uncommit 读未提交，可能会读到其他事务未提交的数据，也叫做脏读。
    一个事务读取到另一个事务尚未提交的数据,称之为脏读

read commit 读已提交，两次读取结果不一致，叫做不可重复读。不可重复读解决了脏读的问题，他只会读取已经提交的事务。
    个事务读取到另一个事务已提交的数据,导致对同一条记录读取两次以上的结果不一致,称之为不可重复读

repeatable read 可重复复读，这是mysql的默认级别，就是每次读取结果都一样，但是有可能产生幻读。
    一个事务读取到另一个事务已经提交的delete或者insert数据,导致对同一张表读取两次以上结果不一致,称之为幻读   

serializable 串行，一般是不会使用的，他会给每一行读取的数据加锁，会导致大量超时和锁竞争的问题。


A原子性由undo log日志保证，它记录了需要回滚的日志信息，事务回滚时撤销已经执行成功的sql
C一致性一般由代码层面来保证
I隔离性由MVCC来保证
D持久性由内存+redo log来保证，mysql修改数据同时在内存和redo log记录这次操作，事务提交的时候通过redo log刷盘，宕机的时候可以从redo log恢复

MVCC叫做多版本并发控制，实际上就是保存了数据在某个时间节点的快照。


# MQ
## 如何保证消息不丢失

生产者弄丢了数据
    可以选择使用rabbitmq提供是事物功能
    可以开启confirm模式

rabbitmq自己丢了数据
    设置消息持久化到磁盘

消费端弄丢了数据
    使用rabbitmq提供的ack机制，首先关闭rabbitmq的自动ack，然后每次在确保处理完这个消息之后，在代码里手动调用ack。这样就可以避免消息还没有处理完就ack。



复杂的问题简单化——拆分
服务提供者，服务消费者，注册中心

服务注册——服务启动时将自己的信息存储在这册中心
服务发现——消费者从注册中心获取服务提供者的网络信息，通过该信息进行服务调用

